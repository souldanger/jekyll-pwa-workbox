this.workbox=this.workbox||{},this.workbox.streams=function(e,n){"use strict";try{self["workbox:streams:5.0.0-alpha.0"]&&_()}catch(e){}function t(e){const t=e.map(e=>Promise.resolve(e).then(e=>(function(e){return e instanceof Response?e.body.getReader():e instanceof ReadableStream?e.getReader():new Response(e).body.getReader()})(e))),r=new n.Deferred;let s=0;const o=new ReadableStream({pull(e){return t[s].then(e=>e.read()).then(n=>{if(n.done)return++s>=t.length?(e.close(),void r.resolve()):this.pull(e);e.enqueue(n.value)}).catch(e=>{throw r.reject(e),e})},cancel(){r.resolve()}});return{done:r.promise,stream:o}}function r(e={}){const n=new Headers(e);return n.has("content-type")||n.set("content-type","text/html"),n}function s(e,n){const{done:s,stream:o}=t(e),a=r(n);return{done:s,response:new Response(o,{headers:a})}}let o;function a(){if(void 0===o)try{new ReadableStream({start(){}}),o=!0}catch(e){o=!1}return o}return e.concatenate=t,e.concatenateToResponse=s,e.isSupported=a,e.strategy=function(e,n){return async({event:t,request:o,url:c,params:i})=>{const u=e.map(e=>Promise.resolve(e({event:t,request:o,url:c,params:i})));if(a()){const{done:e,response:r}=s(u,n);return t&&t.waitUntil(e),r}const f=u.map(async e=>{const n=await e;return n instanceof Response?n.blob():new Response(n).blob()}),l=await Promise.all(f),p=r(n);return new Response(new Blob(l),{headers:p})}},e}({},workbox.core._private);
//# sourceMappingURL=workbox-streams.prod.js.map
