{"version":3,"file":"workbox-strategies.prod.js","sources":["../_version.js","../CacheFirst.js","../CacheOnly.js","../plugins/cacheOkAndOpaquePlugin.js","../NetworkFirst.js","../NetworkOnly.js","../StaleWhileRevalidate.js","../index.js"],"sourcesContent":["// @ts-ignore\ntry {\n    self['workbox:strategies:5.0.0-alpha.0'] && _();\n}\ncatch (e) { }\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { cacheWrapper } from 'workbox-core/_private/cacheWrapper.js';\nimport { fetchWrapper } from 'workbox-core/_private/fetchWrapper.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { messages } from './utils/messages.js';\nimport './_version.js';\n/**\n * An implementation of a [cache-first]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#cache-falling-back-to-network}\n * request strategy.\n *\n * A cache first strategy is useful for assets that have been revisioned,\n * such as URLs like `/styles/example.a8f5f1.css`, since they\n * can be cached for long periods of time.\n *\n * If the network request fails, and there is no cache match, this will throw\n * a `WorkboxError` exception.\n *\n * @memberof workbox.strategies\n */\nclass CacheFirst {\n    /**\n     * @param {Object} options\n     * @param {string} options.cacheName Cache name to store and retrieve\n     * requests. Defaults to cache names provided by\n     * [workbox-core]{@link workbox.core.cacheNames}.\n     * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} options.fetchOptions Values passed along to the\n     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n     * of all fetch() requests made by this strategy.\n     * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n     */\n    constructor(options = {}) {\n        this._cacheName = cacheNames.getRuntimeName(options.cacheName);\n        this._plugins = options.plugins || [];\n        this._fetchOptions = options.fetchOptions;\n        this._matchOptions = options.matchOptions;\n    }\n    /**\n     * This method will perform a request strategy and follows an API that\n     * will work with the\n     * [Workbox Router]{@link workbox.routing.Router}.\n     *\n     * @param {Object} options\n     * @param {Request} options.request The request to run this strategy for.\n     * @param {Event} [options.event] The event that triggered the request.\n     * @return {Promise<Response>}\n     */\n    async handle({ event, request }) {\n        return this.makeRequest({\n            event,\n            request: request || event.request,\n        });\n    }\n    /**\n     * This method can be used to perform a make a standalone request outside the\n     * context of the [Workbox Router]{@link workbox.routing.Router}.\n     *\n     * See \"[Advanced Recipes](https://developers.google.com/web/tools/workbox/guides/advanced-recipes#make-requests)\"\n     * for more usage information.\n     *\n     * @param {Object} options\n     * @param {Request|string} options.request Either a\n     *     [`Request`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Request}\n     *     object, or a string URL, corresponding to the request to be made.\n     * @param {Event} [options.event] If provided, `event.waitUntil()` will\n           be called automatically to extend the service worker's lifetime.\n     * @return {Promise<Response>}\n     */\n    async makeRequest({ event, request }) {\n        const logs = [];\n        if (typeof request === 'string') {\n            request = new Request(request);\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(request, Request, {\n                moduleName: 'workbox-strategies',\n                className: 'CacheFirst',\n                funcName: 'makeRequest',\n                paramName: 'request',\n            });\n        }\n        let response = await cacheWrapper.match({\n            cacheName: this._cacheName,\n            request,\n            event,\n            matchOptions: this._matchOptions,\n            plugins: this._plugins,\n        });\n        let error;\n        if (!response) {\n            if (process.env.NODE_ENV !== 'production') {\n                logs.push(`No response found in the '${this._cacheName}' cache. ` +\n                    `Will respond with a network request.`);\n            }\n            try {\n                response = await this._getFromNetwork(request, event);\n            }\n            catch (err) {\n                error = err;\n            }\n            if (process.env.NODE_ENV !== 'production') {\n                if (response) {\n                    logs.push(`Got response from network.`);\n                }\n                else {\n                    logs.push(`Unable to get a response from the network.`);\n                }\n            }\n        }\n        else {\n            if (process.env.NODE_ENV !== 'production') {\n                logs.push(`Found a cached response in the '${this._cacheName}' cache.`);\n            }\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            logger.groupCollapsed(messages.strategyStart('CacheFirst', request));\n            for (let log of logs) {\n                logger.log(log);\n            }\n            messages.printFinalResponse(response);\n            logger.groupEnd();\n        }\n        if (!response) {\n            throw new WorkboxError('no-response', { url: request.url, error });\n        }\n        return response;\n    }\n    /**\n     * Handles the network and cache part of CacheFirst.\n     *\n     * @param {Request} request\n     * @param {Event} [event]\n     * @return {Promise<Response>}\n     *\n     * @private\n     */\n    async _getFromNetwork(request, event) {\n        const response = await fetchWrapper.fetch({\n            request,\n            event,\n            fetchOptions: this._fetchOptions,\n            plugins: this._plugins,\n        });\n        // Keep the service worker while we put the request to the cache\n        const responseClone = response.clone();\n        const cachePutPromise = cacheWrapper.put({\n            cacheName: this._cacheName,\n            request,\n            response: responseClone,\n            event,\n            plugins: this._plugins,\n        });\n        if (event) {\n            try {\n                event.waitUntil(cachePutPromise);\n            }\n            catch (error) {\n                if (process.env.NODE_ENV !== 'production') {\n                    logger.warn(`Unable to ensure service worker stays alive when ` +\n                        `updating cache for '${getFriendlyURL(request.url)}'.`);\n                }\n            }\n        }\n        return response;\n    }\n}\nexport { CacheFirst };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { cacheWrapper } from 'workbox-core/_private/cacheWrapper.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { messages } from './utils/messages.js';\nimport './_version.js';\n/**\n * An implementation of a\n * [cache-only]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#cache-only}\n * request strategy.\n *\n * This class is useful if you want to take advantage of any\n * [Workbox plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}.\n *\n * If there is no cache match, this will throw a `WorkboxError` exception.\n *\n * @memberof workbox.strategies\n */\nclass CacheOnly {\n    /**\n     * @param {Object} options\n     * @param {string} options.cacheName Cache name to store and retrieve\n     * requests. Defaults to cache names provided by\n     * [workbox-core]{@link workbox.core.cacheNames}.\n     * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n     */\n    constructor(options = {}) {\n        this._cacheName = cacheNames.getRuntimeName(options.cacheName);\n        this._plugins = options.plugins || [];\n        this._matchOptions = options.matchOptions;\n    }\n    /**\n     * This method will perform a request strategy and follows an API that\n     * will work with the\n     * [Workbox Router]{@link workbox.routing.Router}.\n     *\n     * @param {Object} options\n     * @param {Request} options.request The request to run this strategy for.\n     * @param {Event} [options.event] The event that triggered the request.\n     * @return {Promise<Response>}\n     */\n    async handle({ event, request }) {\n        return this.makeRequest({\n            event,\n            request: request || event.request,\n        });\n    }\n    /**\n     * This method can be used to perform a make a standalone request outside the\n     * context of the [Workbox Router]{@link workbox.routing.Router}.\n     *\n     * See \"[Advanced Recipes](https://developers.google.com/web/tools/workbox/guides/advanced-recipes#make-requests)\"\n     * for more usage information.\n     *\n     * @param {Object} options\n     * @param {Request|string} options.request Either a\n     *     [`Request`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Request}\n     *     object, or a string URL, corresponding to the request to be made.\n     * @param {FetchEvent} [options.event] If provided, `event.waitUntil()` will\n     *     be called automatically to extend the service worker's lifetime.\n     * @return {Promise<Response>}\n     */\n    async makeRequest({ event, request }) {\n        if (typeof request === 'string') {\n            request = new Request(request);\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(request, Request, {\n                moduleName: 'workbox-strategies',\n                className: 'CacheOnly',\n                funcName: 'makeRequest',\n                paramName: 'request',\n            });\n        }\n        const response = await cacheWrapper.match({\n            cacheName: this._cacheName,\n            request,\n            event,\n            matchOptions: this._matchOptions,\n            plugins: this._plugins,\n        });\n        if (process.env.NODE_ENV !== 'production') {\n            logger.groupCollapsed(messages.strategyStart('CacheOnly', request));\n            if (response) {\n                logger.log(`Found a cached response in the '${this._cacheName}'` +\n                    ` cache.`);\n                messages.printFinalResponse(response);\n            }\n            else {\n                logger.log(`No response found in the '${this._cacheName}' cache.`);\n            }\n            logger.groupEnd();\n        }\n        if (!response) {\n            throw new WorkboxError('no-response', { url: request.url });\n        }\n        return response;\n    }\n}\nexport { CacheOnly };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\nexport const cacheOkAndOpaquePlugin = {\n    /**\n     * Returns a valid response (to allow caching) if the status is 200 (OK) or\n     * 0 (opaque).\n     *\n     * @param {Object} options\n     * @param {Response} options.response\n     * @return {Response|null}\n     *\n     * @private\n     */\n    cacheWillUpdate: async ({ response }) => {\n        if (response.status === 200 || response.status === 0) {\n            return response;\n        }\n        return null;\n    },\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { cacheWrapper } from 'workbox-core/_private/cacheWrapper.js';\nimport { fetchWrapper } from 'workbox-core/_private/fetchWrapper.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { messages } from './utils/messages.js';\nimport { cacheOkAndOpaquePlugin } from './plugins/cacheOkAndOpaquePlugin.js';\nimport './_version.js';\n/**\n * An implementation of a\n * [network first]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#network-falling-back-to-cache}\n * request strategy.\n *\n * By default, this strategy will cache responses with a 200 status code as\n * well as [opaque responses]{@link https://developers.google.com/web/tools/workbox/guides/handle-third-party-requests}.\n * Opaque responses are are cross-origin requests where the response doesn't\n * support [CORS]{@link https://enable-cors.org/}.\n *\n * If the network request fails, and there is no cache match, this will throw\n * a `WorkboxError` exception.\n *\n * @memberof workbox.strategies\n */\nclass NetworkFirst {\n    /**\n     * @param {Object} options\n     * @param {string} options.cacheName Cache name to store and retrieve\n     * requests. Defaults to cache names provided by\n     * [workbox-core]{@link workbox.core.cacheNames}.\n     * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} options.fetchOptions Values passed along to the\n     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n     * of all fetch() requests made by this strategy.\n     * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n     * @param {number} options.networkTimeoutSeconds If set, any network requests\n     * that fail to respond within the timeout will fallback to the cache.\n     *\n     * This option can be used to combat\n     * \"[lie-fi]{@link https://developers.google.com/web/fundamentals/performance/poor-connectivity/#lie-fi}\"\n     * scenarios.\n     */\n    constructor(options = {}) {\n        this._cacheName = cacheNames.getRuntimeName(options.cacheName);\n        if (options.plugins) {\n            let isUsingCacheWillUpdate = options.plugins.some((plugin) => !!plugin.cacheWillUpdate);\n            this._plugins = isUsingCacheWillUpdate ?\n                options.plugins : [cacheOkAndOpaquePlugin, ...options.plugins];\n        }\n        else {\n            // No plugins passed in, use the default plugin.\n            this._plugins = [cacheOkAndOpaquePlugin];\n        }\n        this._networkTimeoutSeconds = options.networkTimeoutSeconds || 0;\n        if (process.env.NODE_ENV !== 'production') {\n            if (this._networkTimeoutSeconds) {\n                assert.isType(this._networkTimeoutSeconds, 'number', {\n                    moduleName: 'workbox-strategies',\n                    className: 'NetworkFirst',\n                    funcName: 'constructor',\n                    paramName: 'networkTimeoutSeconds',\n                });\n            }\n        }\n        this._fetchOptions = options.fetchOptions;\n        this._matchOptions = options.matchOptions;\n    }\n    /**\n     * This method will perform a request strategy and follows an API that\n     * will work with the\n     * [Workbox Router]{@link workbox.routing.Router}.\n     *\n     * @param {Object} options\n     * @param {Request} options.request The request to run this strategy for.\n     * @param {Event} [options.event] The event that triggered the request.\n     * @return {Promise<Response>}\n     */\n    async handle({ event, request }) {\n        return this.makeRequest({\n            event,\n            request: request || event.request,\n        });\n    }\n    /**\n     * This method can be used to perform a make a standalone request outside the\n     * context of the [Workbox Router]{@link workbox.routing.Router}.\n     *\n     * See \"[Advanced Recipes](https://developers.google.com/web/tools/workbox/guides/advanced-recipes#make-requests)\"\n     * for more usage information.\n     *\n     * @param {Object} options\n     * @param {Request|string} options.request Either a\n     *     [`Request`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Request}\n     *     object, or a string URL, corresponding to the request to be made.\n     * @param {FetchEvent} [options.event] If provided, `event.waitUntil()` will\n     *     be called automatically to extend the service worker's lifetime.\n     * @return {Promise<Response>}\n     */\n    async makeRequest({ event, request }) {\n        const logs = [];\n        if (typeof request === 'string') {\n            request = new Request(request);\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(request, Request, {\n                moduleName: 'workbox-strategies',\n                className: 'NetworkFirst',\n                funcName: 'handle',\n                paramName: 'makeRequest',\n            });\n        }\n        const promises = [];\n        let timeoutId;\n        if (this._networkTimeoutSeconds) {\n            const { id, promise } = this._getTimeoutPromise({ request, event, logs });\n            timeoutId = id;\n            promises.push(promise);\n        }\n        const networkPromise = this._getNetworkPromise({ timeoutId, request, event, logs });\n        promises.push(networkPromise);\n        // Promise.race() will resolve as soon as the first promise resolves.\n        let response = await Promise.race(promises);\n        // If Promise.race() resolved with null, it might be due to a network\n        // timeout + a cache miss. If that were to happen, we'd rather wait until\n        // the networkPromise resolves instead of returning null.\n        // Note that it's fine to await an already-resolved promise, so we don't\n        // have to check to see if it's still \"in flight\".\n        if (!response) {\n            response = await networkPromise;\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            logger.groupCollapsed(messages.strategyStart('NetworkFirst', request));\n            for (let log of logs) {\n                logger.log(log);\n            }\n            messages.printFinalResponse(response);\n            logger.groupEnd();\n        }\n        if (!response) {\n            throw new WorkboxError('no-response', { url: request.url });\n        }\n        return response;\n    }\n    /**\n     * @param {Object} options\n     * @param {Request} options.request\n     * @param {Array} options.logs A reference to the logs array\n     * @param {Event} [options.event]\n     * @return {Promise<Response>}\n     *\n     * @private\n     */\n    _getTimeoutPromise({ request, logs, event }) {\n        let timeoutId;\n        const timeoutPromise = new Promise((resolve) => {\n            const onNetworkTimeout = async () => {\n                if (process.env.NODE_ENV !== 'production') {\n                    logs.push(`Timing out the network response at ` +\n                        `${this._networkTimeoutSeconds} seconds.`);\n                }\n                resolve(await this._respondFromCache({ request, event }));\n            };\n            timeoutId = setTimeout(onNetworkTimeout, this._networkTimeoutSeconds * 1000);\n        });\n        return {\n            promise: timeoutPromise,\n            id: timeoutId,\n        };\n    }\n    /**\n     * @param {Object} options\n     * @param {number|undefined} options.timeoutId\n     * @param {Request} options.request\n     * @param {Array} options.logs A reference to the logs Array.\n     * @param {Event} [options.event]\n     * @return {Promise<Response>}\n     *\n     * @private\n     */\n    async _getNetworkPromise({ timeoutId, request, logs, event }) {\n        let error;\n        let response;\n        try {\n            response = await fetchWrapper.fetch({\n                request,\n                event,\n                fetchOptions: this._fetchOptions,\n                plugins: this._plugins,\n            });\n        }\n        catch (err) {\n            error = err;\n        }\n        if (timeoutId) {\n            clearTimeout(timeoutId);\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            if (response) {\n                logs.push(`Got response from network.`);\n            }\n            else {\n                logs.push(`Unable to get a response from the network. Will respond ` +\n                    `with a cached response.`);\n            }\n        }\n        if (error || !response) {\n            response = await this._respondFromCache({ request, event });\n            if (process.env.NODE_ENV !== 'production') {\n                if (response) {\n                    logs.push(`Found a cached response in the '${this._cacheName}'` +\n                        ` cache.`);\n                }\n                else {\n                    logs.push(`No response found in the '${this._cacheName}' cache.`);\n                }\n            }\n        }\n        else {\n            // Keep the service worker alive while we put the request in the cache\n            const responseClone = response.clone();\n            const cachePut = cacheWrapper.put({\n                cacheName: this._cacheName,\n                request,\n                response: responseClone,\n                event,\n                plugins: this._plugins,\n            });\n            if (event) {\n                try {\n                    // The event has been responded to so we can keep the SW alive to\n                    // respond to the request\n                    event.waitUntil(cachePut);\n                }\n                catch (err) {\n                    if (process.env.NODE_ENV !== 'production') {\n                        logger.warn(`Unable to ensure service worker stays alive when ` +\n                            `updating cache for '${getFriendlyURL(request.url)}'.`);\n                    }\n                }\n            }\n        }\n        return response;\n    }\n    /**\n     * Used if the network timeouts or fails to make the request.\n     *\n     * @param {Object} options\n     * @param {Request} request The request to match in the cache\n     * @param {Event} [options.event]\n     * @return {Promise<Object>}\n     *\n     * @private\n     */\n    _respondFromCache({ event, request }) {\n        return cacheWrapper.match({\n            cacheName: this._cacheName,\n            request,\n            event,\n            matchOptions: this._matchOptions,\n            plugins: this._plugins,\n        });\n    }\n}\nexport { NetworkFirst };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { fetchWrapper } from 'workbox-core/_private/fetchWrapper.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { messages } from './utils/messages.js';\nimport './_version.js';\n/**\n * An implementation of a\n * [network-only]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#network-only}\n * request strategy.\n *\n * This class is useful if you want to take advantage of any\n * [Workbox plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}.\n *\n * If the network request fails, this will throw a `WorkboxError` exception.\n *\n * @memberof workbox.strategies\n */\nclass NetworkOnly {\n    /**\n     * @param {Object} options\n     * @param {string} options.cacheName Cache name to store and retrieve\n     * requests. Defaults to cache names provided by\n     * [workbox-core]{@link workbox.core.cacheNames}.\n     * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} options.fetchOptions Values passed along to the\n     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n     * of all fetch() requests made by this strategy.\n     */\n    constructor(options = {}) {\n        this._plugins = options.plugins || [];\n        this._fetchOptions = options.fetchOptions;\n    }\n    /**\n     * This method will perform a request strategy and follows an API that\n     * will work with the\n     * [Workbox Router]{@link workbox.routing.Router}.\n     *\n     * @param {Object} options\n     * @param {Request} options.request The request to run this strategy for.\n     * @param {Event} [options.event] The event that triggered the request.\n     * @return {Promise<Response>}\n     */\n    async handle({ event, request }) {\n        return this.makeRequest({\n            event,\n            request: request || event.request,\n        });\n    }\n    /**\n     * This method can be used to perform a make a standalone request outside the\n     * context of the [Workbox Router]{@link workbox.routing.Router}.\n     *\n     * See \"[Advanced Recipes](https://developers.google.com/web/tools/workbox/guides/advanced-recipes#make-requests)\"\n     * for more usage information.\n     *\n     * @param {Object} options\n     * @param {Request|string} options.request Either a\n     *     [`Request`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Request}\n     *     object, or a string URL, corresponding to the request to be made.\n     * @param {FetchEvent} [options.event] If provided, `event.waitUntil()` will\n     *     be called automatically to extend the service worker's lifetime.\n     * @return {Promise<Response>}\n     */\n    async makeRequest({ event, request }) {\n        if (typeof request === 'string') {\n            request = new Request(request);\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(request, Request, {\n                moduleName: 'workbox-strategies',\n                className: 'NetworkOnly',\n                funcName: 'handle',\n                paramName: 'request',\n            });\n        }\n        let error;\n        let response;\n        try {\n            response = await fetchWrapper.fetch({\n                request,\n                event,\n                fetchOptions: this._fetchOptions,\n                plugins: this._plugins,\n            });\n        }\n        catch (err) {\n            error = err;\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            logger.groupCollapsed(messages.strategyStart('NetworkOnly', request));\n            if (response) {\n                logger.log(`Got response from network.`);\n            }\n            else {\n                logger.log(`Unable to get a response from the network.`);\n            }\n            messages.printFinalResponse(response);\n            logger.groupEnd();\n        }\n        if (!response) {\n            throw new WorkboxError('no-response', { url: request.url, error });\n        }\n        return response;\n    }\n}\nexport { NetworkOnly };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { cacheWrapper } from 'workbox-core/_private/cacheWrapper.js';\nimport { fetchWrapper } from 'workbox-core/_private/fetchWrapper.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { messages } from './utils/messages.js';\nimport { cacheOkAndOpaquePlugin } from './plugins/cacheOkAndOpaquePlugin.js';\nimport './_version.js';\n/**\n * An implementation of a\n * [stale-while-revalidate]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#stale-while-revalidate}\n * request strategy.\n *\n * Resources are requested from both the cache and the network in parallel.\n * The strategy will respond with the cached version if available, otherwise\n * wait for the network response. The cache is updated with the network response\n * with each successful request.\n *\n * By default, this strategy will cache responses with a 200 status code as\n * well as [opaque responses]{@link https://developers.google.com/web/tools/workbox/guides/handle-third-party-requests}.\n * Opaque responses are are cross-origin requests where the response doesn't\n * support [CORS]{@link https://enable-cors.org/}.\n *\n * If the network request fails, and there is no cache match, this will throw\n * a `WorkboxError` exception.\n *\n * @memberof workbox.strategies\n */\nclass StaleWhileRevalidate {\n    /**\n     * @param {Object} options\n     * @param {string} options.cacheName Cache name to store and retrieve\n     * requests. Defaults to cache names provided by\n     * [workbox-core]{@link workbox.core.cacheNames}.\n     * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} options.fetchOptions Values passed along to the\n     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n     * of all fetch() requests made by this strategy.\n     * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n     */\n    constructor(options = {}) {\n        this._cacheName = cacheNames.getRuntimeName(options.cacheName);\n        this._plugins = options.plugins || [];\n        if (options.plugins) {\n            let isUsingCacheWillUpdate = options.plugins.some((plugin) => !!plugin.cacheWillUpdate);\n            this._plugins = isUsingCacheWillUpdate ?\n                options.plugins : [cacheOkAndOpaquePlugin, ...options.plugins];\n        }\n        else {\n            // No plugins passed in, use the default plugin.\n            this._plugins = [cacheOkAndOpaquePlugin];\n        }\n        this._fetchOptions = options.fetchOptions;\n        this._matchOptions = options.matchOptions;\n    }\n    /**\n     * This method will perform a request strategy and follows an API that\n     * will work with the\n     * [Workbox Router]{@link workbox.routing.Router}.\n     *\n     * @param {Object} options\n     * @param {Request} options.request The request to run this strategy for.\n     * @param {Event} [options.event] The event that triggered the request.\n     * @return {Promise<Response>}\n     */\n    async handle({ event, request }) {\n        return this.makeRequest({\n            event,\n            request: request || event.request,\n        });\n    }\n    /**\n     * This method can be used to perform a make a standalone request outside the\n     * context of the [Workbox Router]{@link workbox.routing.Router}.\n     *\n     * See \"[Advanced Recipes](https://developers.google.com/web/tools/workbox/guides/advanced-recipes#make-requests)\"\n     * for more usage information.\n     *\n     * @param {Object} options\n     * @param {Request|string} options.request Either a\n     *     [`Request`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Request}\n     *     object, or a string URL, corresponding to the request to be made.\n     * @param {FetchEvent} [options.event] If provided, `event.waitUntil()` will\n     *     be called automatically to extend the service worker's lifetime.\n     * @return {Promise<Response>}\n     */\n    async makeRequest({ event, request }) {\n        const logs = [];\n        if (typeof request === 'string') {\n            request = new Request(request);\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(request, Request, {\n                moduleName: 'workbox-strategies',\n                className: 'StaleWhileRevalidate',\n                funcName: 'handle',\n                paramName: 'request',\n            });\n        }\n        const fetchAndCachePromise = this._getFromNetwork({ request, event });\n        let response = await cacheWrapper.match({\n            cacheName: this._cacheName,\n            request,\n            event,\n            matchOptions: this._matchOptions,\n            plugins: this._plugins,\n        });\n        let error;\n        if (response) {\n            if (process.env.NODE_ENV !== 'production') {\n                logs.push(`Found a cached response in the '${this._cacheName}'` +\n                    ` cache. Will update with the network response in the background.`);\n            }\n            if (event) {\n                try {\n                    event.waitUntil(fetchAndCachePromise);\n                }\n                catch (error) {\n                    if (process.env.NODE_ENV !== 'production') {\n                        logger.warn(`Unable to ensure service worker stays alive when ` +\n                            `updating cache for '${getFriendlyURL(request.url)}'.`);\n                    }\n                }\n            }\n        }\n        else {\n            if (process.env.NODE_ENV !== 'production') {\n                logs.push(`No response found in the '${this._cacheName}' cache. ` +\n                    `Will wait for the network response.`);\n            }\n            try {\n                response = await fetchAndCachePromise;\n            }\n            catch (err) {\n                error = err;\n            }\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            logger.groupCollapsed(messages.strategyStart('StaleWhileRevalidate', request));\n            for (let log of logs) {\n                logger.log(log);\n            }\n            messages.printFinalResponse(response);\n            logger.groupEnd();\n        }\n        if (!response) {\n            throw new WorkboxError('no-response', { url: request.url, error });\n        }\n        return response;\n    }\n    /**\n     * @param {Object} options\n     * @param {Request} options.request\n     * @param {Event} [options.event]\n     * @return {Promise<Response>}\n     *\n     * @private\n     */\n    async _getFromNetwork({ request, event }) {\n        const response = await fetchWrapper.fetch({\n            request,\n            event,\n            fetchOptions: this._fetchOptions,\n            plugins: this._plugins,\n        });\n        const cachePutPromise = cacheWrapper.put({\n            cacheName: this._cacheName,\n            request,\n            response: response.clone(),\n            event,\n            plugins: this._plugins,\n        });\n        if (event) {\n            try {\n                event.waitUntil(cachePutPromise);\n            }\n            catch (error) {\n                if (process.env.NODE_ENV !== 'production') {\n                    logger.warn(`Unable to ensure service worker stays alive when ` +\n                        `updating cache for '${getFriendlyURL(request.url)}'.`);\n                }\n            }\n        }\n        return response;\n    }\n}\nexport { StaleWhileRevalidate };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { CacheFirst } from './CacheFirst.js';\nimport { CacheOnly } from './CacheOnly.js';\nimport { NetworkFirst } from './NetworkFirst.js';\nimport { NetworkOnly } from './NetworkOnly.js';\nimport { StaleWhileRevalidate } from './StaleWhileRevalidate.js';\nimport './_version.js';\nconst mapping = {\n    cacheFirst: CacheFirst,\n    cacheOnly: CacheOnly,\n    networkFirst: NetworkFirst,\n    networkOnly: NetworkOnly,\n    staleWhileRevalidate: StaleWhileRevalidate,\n};\nconst deprecate = (strategy) => {\n    const StrategyCtr = mapping[strategy];\n    return (options) => {\n        if (process.env.NODE_ENV !== 'production') {\n            const strategyCtrName = strategy[0].toUpperCase() + strategy.slice(1);\n            logger.warn(`The 'workbox.strategies.${strategy}()' function has been ` +\n                `deprecated and will be removed in a future version of Workbox.\\n` +\n                `Please use 'new workbox.strategies.${strategyCtrName}()' instead.`);\n        }\n        return new StrategyCtr(options);\n    };\n};\n/**\n * @function workbox.strategies.cacheFirst\n * @param {Object} options See the {@link workbox.strategies.CacheFirst}\n * constructor for more info.\n * @deprecated since v4.0.0\n */\nconst cacheFirst = deprecate('cacheFirst');\n/**\n * @function workbox.strategies.cacheOnly\n * @param {Object} options See the {@link workbox.strategies.CacheOnly}\n * constructor for more info.\n * @deprecated since v4.0.0\n */\nconst cacheOnly = deprecate('cacheOnly');\n/**\n * @function workbox.strategies.networkFirst\n * @param {Object} options See the {@link workbox.strategies.NetworkFirst}\n * constructor for more info.\n * @deprecated since v4.0.0\n */\nconst networkFirst = deprecate('networkFirst');\n/**\n * @function workbox.strategies.networkOnly\n * @param {Object} options See the {@link workbox.strategies.NetworkOnly}\n * constructor for more info.\n * @deprecated since v4.0.0\n */\nconst networkOnly = deprecate('networkOnly');\n/**\n * @function workbox.strategies.staleWhileRevalidate\n * @param {Object} options See the\n * {@link workbox.strategies.StaleWhileRevalidate} constructor for more info.\n * @deprecated since v4.0.0\n */\nconst staleWhileRevalidate = deprecate('staleWhileRevalidate');\n/**\n * There are common caching strategies that most service workers will need\n * and use. This module provides simple implementations of these strategies.\n *\n * @namespace workbox.strategies\n */\nexport { CacheFirst, CacheOnly, NetworkFirst, NetworkOnly, StaleWhileRevalidate, \n// Deprecated...\ncacheFirst, cacheOnly, networkFirst, networkOnly, staleWhileRevalidate, };\n"],"names":["self","_","e","CacheFirst","constructor","options","_cacheName","cacheNames","getRuntimeName","cacheName","_plugins","plugins","_fetchOptions","fetchOptions","_matchOptions","matchOptions","event","request","this","makeRequest","Request","error","response","cacheWrapper","match","_getFromNetwork","err","WorkboxError","url","fetchWrapper","fetch","responseClone","clone","cachePutPromise","put","waitUntil","CacheOnly","cacheOkAndOpaquePlugin","cacheWillUpdate","async","status","NetworkFirst","isUsingCacheWillUpdate","some","plugin","_networkTimeoutSeconds","networkTimeoutSeconds","logs","promises","timeoutId","id","promise","_getTimeoutPromise","push","networkPromise","_getNetworkPromise","Promise","race","resolve","setTimeout","_respondFromCache","clearTimeout","cachePut","NetworkOnly","StaleWhileRevalidate","fetchAndCachePromise","mapping","cacheFirst","cacheOnly","networkFirst","networkOnly","staleWhileRevalidate","deprecate","strategy","StrategyCtr"],"mappings":"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"}