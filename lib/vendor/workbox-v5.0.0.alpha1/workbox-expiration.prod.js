this.workbox=this.workbox||{},this.workbox.expiration=function(t,s,e,i,a,n){"use strict";try{self["workbox:expiration:5.0.0-alpha.0"]&&_()}catch(t){}const h="workbox-expiration",r="cache-entries",c=t=>{const s=new URL(t,location.href);return s.hash="",s.href};class o{constructor(t){this.t=t,this.s=new s.DBWrapper(h,1,{onupgradeneeded:t=>this.i(t)})}i(t){const s=t.target.result.createObjectStore(r,{keyPath:"id"});s.createIndex("cacheName","cacheName",{unique:!1}),s.createIndex("timestamp","timestamp",{unique:!1}),e.deleteDatabase(this.t)}async setTimestamp(t,s){const e={url:t=c(t),timestamp:s,cacheName:this.t,id:this.h(t)};await this.s.put(r,e)}async getTimestamp(t){return(await this.s.get(r,this.h(t))).timestamp}async expireEntries(t,s){const e=await this.s.transaction(r,"readwrite",(e,i)=>{const a=e.objectStore(r).index("timestamp").openCursor(null,"prev"),n=[];let h=0;a.onsuccess=(()=>{const e=a.result;if(e){const i=e.value;i.cacheName===this.t&&(t&&i.timestamp<t||s&&h>=s?n.push(e.value):h++),e.continue()}else i(n)})}),i=[];for(const t of e)await this.s.delete(r,t.id),i.push(t.url);return i}h(t){return this.t+"|"+c(t)}}class u{constructor(t,s={}){this.o=!1,this.u=!1,this.l=s.maxEntries,this.m=s.maxAgeSeconds,this.t=t,this.p=new o(t)}async expireEntries(){if(this.o)return void(this.u=!0);this.o=!0;const t=this.m?Date.now()-1e3*this.m:0,s=await this.p.expireEntries(t,this.l),e=await caches.open(this.t);for(const t of s)await e.delete(t);this.o=!1,this.u&&(this.u=!1,this.expireEntries())}async updateTimestamp(t){await this.p.setTimestamp(t,Date.now())}async isURLExpired(t){if(this.m){return await this.p.getTimestamp(t)<Date.now()-1e3*this.m}return!1}async delete(){this.u=!1,await this.p.expireEntries(1/0)}}return t.CacheExpiration=u,t.Plugin=class{constructor(t={}){this.cachedResponseWillBeUsed=(async({event:t,request:s,cacheName:e,cachedResponse:i})=>{if(!i)return null;let a=this.k(i);const n=this.D(e);n.expireEntries();const h=n.updateTimestamp(s.url);if(t)try{t.waitUntil(h)}catch(t){}return a?i:null}),this.cacheDidUpdate=(async({cacheName:t,request:s})=>{const e=this.D(t);await e.updateTimestamp(s.url),await e.expireEntries()}),this.N=t,this.m=t.maxAgeSeconds,this.g=new Map,t.purgeOnQuotaError&&n.registerQuotaErrorCallback(()=>this.deleteCacheAndMetadata())}D(t){if(t===a.cacheNames.getRuntimeName())throw new i.WorkboxError("expire-custom-caches-only");let s=this.g.get(t);return s||(s=new u(t,this.N),this.g.set(t,s)),s}k(t){if(!this.m)return!0;const s=this._(t);return null===s||s>=Date.now()-1e3*this.m}_(t){if(!t.headers.has("date"))return null;const s=t.headers.get("date"),e=new Date(s).getTime();return isNaN(e)?null:e}async deleteCacheAndMetadata(){for(const[t,s]of this.g)await caches.delete(t),await s.delete();this.g=new Map}},t}({},workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core);
//# sourceMappingURL=workbox-expiration.prod.js.map
