this.workbox=this.workbox||{},this.workbox.backgroundSync=function(t,e,s,i,n){"use strict";try{self["workbox:background-sync:5.0.0"]&&_()}catch(t){}const a=3,r="workbox-background-sync",c="requests",h="queueName";class o{constructor(t){this.t=t,this.s=new n.DBWrapper(r,a,{onupgradeneeded:this.i})}async pushEntry(t){delete t.id,t.queueName=this.t,await this.s.add(c,t)}async unshiftEntry(t){const[e]=await this.s.getAllMatching(c,{count:1});e?t.id=e.id-1:delete t.id,t.queueName=this.t,await this.s.add(c,t)}async popEntry(){return this.h({direction:"prev"})}async shiftEntry(){return this.h({direction:"next"})}async getAll(){return await this.s.getAllMatching(c,{index:h,query:IDBKeyRange.only(this.t)})}async deleteEntry(t){await this.s.delete(c,t)}async h({direction:t}){const[e]=await this.s.getAllMatching(c,{direction:t,index:h,query:IDBKeyRange.only(this.t),count:1});if(e)return await this.deleteEntry(e.id),e}i(t){const e=t.target.result;t.oldVersion>0&&t.oldVersion<a&&e.objectStoreNames.contains(c)&&e.deleteObjectStore(c),e.createObjectStore(c,{autoIncrement:!0,keyPath:"id"}).createIndex(h,h,{unique:!1})}}const u=["method","referrer","referrerPolicy","mode","credentials","cache","redirect","integrity","keepalive"];class y{static async fromRequest(t){const e={url:t.url,headers:{}};"GET"!==t.method&&(e.body=await t.clone().arrayBuffer());for(const[s,i]of t.headers.entries())e.headers[s]=i;for(const s of u)void 0!==t[s]&&(e[s]=t[s]);return new y(e)}constructor(t){"navigate"===t.mode&&(t.mode="same-origin"),this.o=t}toObject(){const t=Object.assign({},this.o);return t.headers=Object.assign({},this.o.headers),t.body&&(t.body=t.body.slice(0)),t}toRequest(){return new Request(this.o.url,this.o)}clone(){return new y(this.toObject())}}const w="workbox-background-sync",f=10080,d=new Set;class l{constructor(t,{onSync:s,maxRetentionTime:i}={}){if(this.u=!1,this.l=!1,d.has(t))throw new e.WorkboxError("duplicate-queue-name",{name:t});d.add(t),this.q=t,this.m=s||this.replayRequests,this.p=i||f,this.g=new o(this.q),this.R()}get name(){return this.q}async pushRequest(t){await this.k(t,"push")}async unshiftRequest(t){await this.k(t,"unshift")}async popRequest(){return this.D("pop")}async shiftRequest(){return this.D("shift")}async getAll(){const t=await this.g.getAll(),e=Date.now(),s=[];for(const i of t){const t=60*this.p*1e3;e-i.timestamp>t?await this.g.deleteEntry(i.id):s.push(q(i))}return s}async k({request:t,metadata:e,timestamp:s=Date.now()},i){const n={requestData:(await y.fromRequest(t.clone())).toObject(),timestamp:s};e&&(n.metadata=e),await this.g[`${i}Entry`](n),this.u?this.l=!0:await this.registerSync()}async D(t){const e=Date.now(),s=await this.g[`${t}Entry`]();if(s){const i=60*this.p*1e3;return e-s.timestamp>i?this.D(t):q(s)}}async replayRequests(){let t;for(;t=await this.shiftRequest();)try{await fetch(t.request.clone())}catch(s){throw await this.unshiftRequest(t),new e.WorkboxError("queue-replay-failed",{name:this.q})}}async registerSync(){if("sync"in self.registration)try{await self.registration.sync.register(`${w}:${this.q}`)}catch(t){}}R(){"sync"in self.registration?self.addEventListener("sync",t=>{if(t.tag===`${w}:${this.q}`){const e=async()=>{let e;this.u=!0;try{await this.m({queue:this})}catch(t){throw e=t}finally{!this.l||e&&!t.lastChance||await this.registerSync(),this.u=!1,this.l=!1}};t.waitUntil(e())}}):this.m({queue:this})}static get _(){return d}}const q=t=>{const e={request:new y(t.requestData).toRequest(),timestamp:t.timestamp};return t.metadata&&(e.metadata=t.metadata),e};return t.BackgroundSyncPlugin=class{constructor(t,e){this.fetchDidFail=(async({request:t})=>{await this.v.pushRequest({request:t})}),this.v=new l(t,e)}},t.Queue=l,t}({},workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private);
//# sourceMappingURL=workbox-background-sync.prod.js.map
